#!/usr/bin/env python3
import os
import sys
from time import time, sleep
import struct
import argparse
import contextlib
import io

from prompt_toolkit import PromptSession
from prompt_toolkit.history import FileHistory
from panda import Panda

ECHO = False
DEBUG = False
STOP_ON_ERROR = False

ENABLE_TX_ADDR = 0x75A
ENABLE_RX_ADDR = 0x75B
ENABLE_MSGS = [
  b'\x41\x00\xA5\x00\xAF\xFE\xDE\xAD',
  b'\x41\x00\xA5\x00',
  b'\x41\x00\xA5\x00',
  b'\x41\x00\x00\x00\xAF\xFE\xDE\xAD',
]
DISABLE_MSG = b'\x41\x00\x06\x00\x00\x00\x00\x00'

TERM_TX_ADDR=0x72A
TERM_RX_ADDR=0x72B
ACTIVATE_MSG = '\x01\x02\x03'
DEACTIVATE_MSG = '\x01\x02\x10'

def get_keys(code):
  s1, _ = struct.unpack(">HH", code)
  k1 = (s1 * s1 + 0x9176) & 0xFFFF
  k2 = k1 ^ 0x9176
  return [
    None,
    struct.pack(">HH", k1, s1),
    struct.pack(">HH", k1, k2),
    None,
  ]

def enable(panda, bus, silent=False):
  if DEBUG: print("--- ENABLE")
  if not silent: print("enable", end=' ')
  panda.can_clear(bus) # flush TX
  panda.can_clear(0xFFFF) # flush RX
  keys = None
  for i, msg in enumerate(ENABLE_MSGS):
    if len(msg) < 8 and keys and keys[i]:
      msg += keys[i]
    panda.can_send(ENABLE_TX_ADDR, msg, bus)
    if DEBUG: print(f'{"" if silent else os.linesep}<-- TX: 0x{msg.hex()}')
    if not silent: print(".", end='', flush=True)

    start = time()
    resp = None
    while not resp:
      msgs = panda.can_recv()
      for addr, t, dat, src in msgs:
        if bus != src or ENABLE_RX_ADDR != addr:
          continue
        if DEBUG: print(f'{"" if silent else os.linesep}--> RX: 0x{dat.hex()}')
        if not silent: print(".", end='', flush=True)
        if not keys:
          keys = get_keys(dat[4:8])
        resp = dat
      if not resp and len(msgs) == 0:
        sleep(0.1)
      if time() - start > 1:
        if not silent: print("")
        raise Exception("failed to enable!")

  if not silent: print("")

def disable(panda, bus):
  if DEBUG: print("--- DISABLE")
  if DEBUG: print(f'<-- TX: 0x{DISABLE_MSG.hex()}')
  panda.can_send(ENABLE_TX_ADDR, DISABLE_MSG, bus)

def activate(panda, bus, silent=False):
  if DEBUG: print("--- ACTIVATE")
  cmd_send(panda, ACTIVATE_MSG, bus, silent=True)
  cmd_recv(panda, bus, silent)

def deactivate(panda, bus):
  if DEBUG: print("--- DEACTIVATE")
  cmd_send(panda, DEACTIVATE_MSG, bus, silent=True)
  # there is no response

def cmd_send(panda, cmd, bus, silent=False):
  if (ECHO or DEBUG) and not silent: print(f"--- {cmd}")
  # exit command is fake
  if cmd.lower() == 'exit':
    return True
  cmd = cmd.encode('latin-1') + b'\r'
  panda.can_clear(bus) # flush TX
  panda.can_clear(0xFFFF) # flush RX
  for i in range(0, len(cmd), 8):
    dat = cmd[i:i+8].ljust(8, b'\x00')
    if DEBUG: print(f'<-- TX: 0x{dat.hex()}')
    panda.can_send(TERM_TX_ADDR, dat, bus)
    # send too fast and the ECU skips messages
    sleep(0.1)
  return False

def normalize_output(output):
  return output.rstrip(b'\x00').replace(b'\r\n', b'\n').replace(b'\r', b'\n')

def parse_output(output, charset='latin-1'):
  output = normalize_output(output)
  lines = output.split(b'\n')
  partial = lines[-1]
  done_idx = [i for i, l in enumerate(lines) if l in [b'OK', b'Unbekanntes Kommando']]
  result = lines[done_idx[0]] != b'OK' if len(done_idx) else None
  last_idx = done_idx[0] if len(done_idx) and not result else -1
  text = [l.decode(charset) for l in lines[:last_idx]]
  return partial, text, result

def cmd_recv(panda, bus, silent=False):
  start = time()
  partial_output = b''
  while True:
    msgs = panda.can_recv()
    for addr, t, dat, src in msgs:
      if bus != src or TERM_RX_ADDR != addr:
        continue
      start = time()
      if DEBUG: print(f'{"" if silent else os.linesep}--> RX: 0x{dat.hex()}')
      partial_output += dat
      partial_output, lines, result = parse_output(partial_output)
      for line in lines:
        if not silent: print(line)
      if result is not None:
        if not silent:
          sys.stdout.flush()
        if result and STOP_ON_ERROR:
          raise Exception("command failed!")
        return

    if len(msgs) == 0:
      sleep(0.1)
    if time() - start > 1:
      if not silent: print("")
      raise Exception("failed to receive!")

def init(bus, speed_kbps, silent=False):
  f = io.StringIO()
  with contextlib.redirect_stdout(f):
    panda = Panda()
  if DEBUG or not silent: print(f.getvalue())
  if bus == -1:
    bus = 1 if panda.has_obd() else 0
  if DEBUG: print(f'--- BUS: {bus}')
  if speed_kbps:
    if DEBUG: print(f'--- SPEED: {speed_kbps} kbps')
    panda.set_can_speed_kbps(bus, speed_kbps)
  panda.set_safety_mode(Panda.SAFETY_ALLOUTPUT)
  return panda, bus

def interactive():
  history = FileHistory(os.path.expanduser('~/.cansh_history'))
  session = PromptSession(message='> ', history=history)

  while True:
    cmd = session.prompt()
    done = cmd_send(panda, cmd, bus)
    if done: return
    cmd_recv(panda, bus)

def non_interactive(source):
    for line in source:
      if line.startswith('#!'):
        continue
      cmd = line.rstrip(' \t\r\n')
      if not cmd:
        continue
      cmd_send(panda, cmd, bus)
      cmd_recv(panda, bus)

if __name__ == "__main__":
  parser = argparse.ArgumentParser()
  parser.add_argument('file', nargs='?', type=argparse.FileType('r'), default=sys.stdin, help='script to run')
  parser.add_argument('-e', action='store_true', help='stop on first error')
  parser.add_argument('-c', metavar='COMMAND', type=str, help='single command to run (then exit)')
  parser.add_argument('-x', action='store_true', help='echo commands executed')
  parser.add_argument('-b', metavar='BUS', type=int, default=-1, help='CAN bus to use')
  parser.add_argument('-s', metavar='SPEED_KBPS', type=int, default=0, help='CAN bus speed in kbps')
  parser.add_argument('-v', action='store_true', help='verbose output')
  args = parser.parse_args()
  is_tty = sys.stdin.isatty() and not args.c and args.file.name == '<stdin>'
  ECHO = args.x
  DEBUG = args.v

  panda, bus = init(args.b, args.s, silent=not is_tty)
  enable(panda, bus, silent=not is_tty)
  try:
    activate(panda, bus, silent=not is_tty)
    if is_tty:
      STOP_ON_ERROR = False
      interactive()
    else:
      STOP_ON_ERROR = args.e
      source = [args.c] if args.c else args.file
      non_interactive(source)
  finally:
    try:
      deactivate(panda, bus)
    finally:
      disable(panda, bus)
